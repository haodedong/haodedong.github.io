<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Hugo Hermit</title><link>https://haodedong.github.io/posts/</link><description>Recent content in Posts on Hugo Hermit</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 06 Mar 2020 14:21:45 +0800</lastBuildDate><atom:link href="https://haodedong.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>My 2 Post</title><link>https://haodedong.github.io/posts/javase%E7%9A%84%E7%90%86%E8%A7%A3/</link><pubDate>Fri, 06 Mar 2020 14:21:45 +0800</pubDate><guid>https://haodedong.github.io/posts/javase%E7%9A%84%E7%90%86%E8%A7%A3/</guid><description>对Java平台的理解
基本语言特性： 简单 Java 语言的语法与C语言和C++ 语言很接近，使得大多数程序员很容易学习和使用Java。另一方面，Java丢弃了C++中很少使用的、很难理解的、令人迷惑 的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java语言不使用指针，并提供了自动的废料收集，使得程序员不必为内存管理而担忧。 面向对象
封装：将同一类事物的特性与功能包装在一起，对外暴露调用的接口 继承：从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力 多态：同一操作（方法）作用于不同的对象时，可以有不同的解释，产生不同的执行结果。 平台无关性：即“书写一次，到处运行”， 意味着Java可以在任何设备上开发，编译成一段标准的字节码并且可以在任何安装有Java虚拟机（JVM）的设备上运行。
分布式：Java 语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包 括URL、URLConnection、Socket、ServerSocket等。Java的RMI(远程方法激活)机制也是开发分布式应用的重要手 段。
健壮： Java的强类型机制、异常处理、废料的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。Java的安全检查机制使得Java更具健壮性。
安全： Java 通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。西安达内交大java培训讲师表示，除了Java语言具有的许多安全特性以 外，Java对通过网络下载的类具有一个安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安 全管理机制（类SecurityManager）让Java应用设置安全哨兵。
体系结构中立： Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件）,然后可以在实现这个Java平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。
可移植： 这种可移植性来源于体系结构中立性，另外，Java还严格规定了各个基本数据类型的长度。Java系统本身也具有很强的可移植性，Java编译器是用Java实现的，Java的运行环境是用ANSIC实现的。
解释型：在运行时，Java平台中的Java解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。
高性能：与那些解释型的高级脚本语言相比，Java的确是高性能的。事实上，Java的运行速度随着JIT(Just-In-Time)编译器技术的发展越来越接近于C++。（PS:JIT 能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行了。）
多线程：有多种方法创建线程，支持多个线程的同时执行，并提供多线程之间的同步机制。
动态：Java程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。
原文链接———&amp;gt;Java初学者必知——Java语言的11大特点 - 狼丶宇先生的网络科技空间 - CSDN博客</description><content type="html"><![CDATA[<ol>
<li>
<p>对Java平台的理解</p>
<ul>
<li>基本语言特性：
<ul>
<li>简单
<ul>
<li>Java 语言的语法与C语言和C++ 语言很接近，使得大多数程序员很容易学习和使用Java。另一方面，Java丢弃了C++中很少使用的、很难理解的、令人迷惑 的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java语言不使用指针，并提供了自动的废料收集，使得程序员不必为内存管理而担忧。</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>面向对象</p>
<ul>
<li>封装：将同一类事物的特性与功能包装在一起，对外暴露调用的接口</li>
<li>继承：从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力</li>
<li>多态：同一操作（方法）作用于不同的对象时，可以有不同的解释，产生不同的执行结果。</li>
</ul>
</li>
<li>
<p>平台无关性：即“书写一次，到处运行”， 意味着Java可以在任何设备上开发，编译成一段标准的字节码并且可以在任何安装有Java虚拟机（JVM）的设备上运行。</p>
</li>
<li>
<p>分布式：Java 语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包 括URL、URLConnection、Socket、ServerSocket等。Java的RMI(远程方法激活)机制也是开发分布式应用的重要手 段。</p>
</li>
<li>
<p>健壮： Java的强类型机制、异常处理、废料的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。Java的安全检查机制使得Java更具健壮性。</p>
</li>
<li>
<p>安全： Java 通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。西安达内交大java培训讲师表示，除了Java语言具有的许多安全特性以 外，Java对通过网络下载的类具有一个安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安 全管理机制（类SecurityManager）让Java应用设置安全哨兵。</p>
</li>
<li>
<p>体系结构中立： Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件）,然后可以在实现这个Java平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。</p>
</li>
<li>
<p>可移植： 这种可移植性来源于体系结构中立性，另外，Java还严格规定了各个基本数据类型的长度。Java系统本身也具有很强的可移植性，Java编译器是用Java实现的，Java的运行环境是用ANSIC实现的。</p>
</li>
<li>
<p>解释型：在运行时，Java平台中的Java解释器对这些字节码进行<strong>解释执行</strong>，执行过程中需要的类在联接阶段被载入到运行环境中。</p>
</li>
<li>
<p>高性能：与那些解释型的高级脚本语言相比，Java的确是高性能的。事实上，Java的运行速度随着JIT(Just-In-Time)编译器技术的发展越来越接近于C++。（PS:<strong>JIT 能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行了。</strong>）</p>
</li>
<li>
<p>多线程：有多种方法创建线程，支持多个线程的同时执行，并提供多线程之间的同步机制。</p>
</li>
<li>
<p>动态：Java程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。</p>
</li>
</ul>
</li>
</ul>
<p>原文链接———&gt;<a href="https://blog.csdn.net/qq_33270001/article/details/81809378">Java初学者必知——Java语言的11大特点 - 狼丶宇先生的网络科技空间 - CSDN博客</a></p>
</li>
<li>
<p>Java采用的是解释和编译混合的模式。它首先通过javac将源码编译成字节码文件class.然后在运行的时候通过解释器或者JIT将字节码转换成最终的机器码。
只是用解释器的缺点：抛弃了JIT可能带来的性能优势。如果代码没有被JIT编译的话，再次运行时需要重复解析。
只用JIT的缺点：
需要将全部的代码编译成本地机器码。要花更多的时间，JVM启动会变慢非常多；
增加可执行代码的长度（字节码比JIT编译后的机器码小很多），这将导致页面调度，从而降低程序的速度。
有些JIT编译器的优化方式，比如分支预测，如果不进行profiling，往往并不能进行有效优化。
因此，HotSpot采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。
JDK 9引入了一种新的编译模式AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。
注：JIT为方法级，它会缓存编译过的字节码在CodeCache中，而不需要被重复解释</p>
</li>
</ol>
]]></content></item><item><title>My First Post</title><link>https://haodedong.github.io/posts/docker%E5%AE%89%E8%A3%85halo%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/</link><pubDate>Fri, 06 Mar 2020 14:21:45 +0800</pubDate><guid>https://haodedong.github.io/posts/docker%E5%AE%89%E8%A3%85halo%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/</guid><description>docker install halo 今天，我使用docker安装halo，按照这个教程来的。
但是由于文档并没有介绍清楚使用mysql应该怎么做 我使用docker安装了mysql5.7。
docker pull mysql:5.7 可能会执行失败，多试几次即可。 然后执行
docker run -d -p 3306:3306 --name mymysql -e MYSQL_ROOT_PASSWORD=mimaxxx mysql:5.7 接下来
docker run --rm -it -d --name halo -p 8090:8090 -v ~/.halo:/root/.halo ruibaby/halo 发现并不能启动halo，于是在代码中查找日志所在位置
logging: level: run.halo.app: INFO file: path: ${user.home}/.halo/logs 在登陆远程服务器后，找到日志文件 spring.log。 发现错误如下
2020-03-04 13:00:47.220 ERROR 6 --- [main] com.zaxxer.hikari.pool.HikariPool : HikariPool-1 - Exception during pool initialization. com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure The last packet sent successfully to the server was 0 milliseconds ago.</description><content type="html"><![CDATA[<h3 id="docker-install-halo">docker install halo</h3>
<p>今天，我使用docker安装halo，按照这个<a href="https://halo.run/archives/install-with-docker">教程</a>来的。</p>
<hr>
<p>但是由于文档并没有介绍清楚使用mysql应该怎么做
我使用docker安装了mysql5.7。</p>
<pre><code>docker pull mysql:5.7
</code></pre><p>可能会执行失败，多试几次即可。
然后执行</p>
<pre><code>docker run -d -p 3306:3306 --name mymysql -e MYSQL_ROOT_PASSWORD=mimaxxx  mysql:5.7
</code></pre><p>接下来</p>
<pre><code>docker run --rm -it -d --name halo -p 8090:8090  -v ~/.halo:/root/.halo ruibaby/halo

</code></pre><p>发现并不能启动halo，于是在代码中查找日志所在位置</p>
<pre><code>logging:
  level:
    run.halo.app: INFO
  file:
    path: ${user.home}/.halo/logs
</code></pre><p>在登陆远程服务器后，找到日志文件 spring.log。
发现错误如下</p>
<pre><code>2020-03-04 13:00:47.220 ERROR 6 --- [main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Exception during pool initialization.

com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure

The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.
	at com.mysql.cj.jdbc.exceptions.SQLError.createCommunicationsException(SQLError.java:174) ~[mysql-connector-java-8.0.18.jar!/:8.0.18]
	at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:64) ~[mysql-connector-java-8.0.18.jar!/:8.0.18]
	at com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:836) ~[mysql-connector-java-8.0.18.jar!/:8.0.18]
	at com.mysql.cj.jdbc.ConnectionImpl.&lt;init&gt;(ConnectionImpl.java:456) ~[mysql-connector-java-8.0.18.jar!/:8.0.18]
	at com.mysql.cj.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:246) ~[mysql-connector-java-8.0.18.jar!/:8.0.18]
	at com.mysql.cj.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:199) ~[mysql-connector-java-8.0.18.jar!/:8.0.18]
	at com.zaxxer.hikari.util.DriverDataSource.getConnection(DriverDataSource.java:138) ~[HikariCP-3.4.1.jar!/:na]
	at com.zaxxer.hikari.pool.PoolBase.newConnection(PoolBase.java:353) ~[HikariCP-3.4.1.jar!/:na]
	at com.zaxxer.hikari.pool.PoolBase.newPoolEntry(PoolBase.java:201) ~[HikariCP-3.4.1.jar!/:na]
	at com.zaxxer.hikari.pool.HikariPool.createPoolEntry(HikariPool.java:473) [HikariCP-3.4.1.jar!/:na]
	at com.zaxxer.hikari.pool.HikariPool.checkFailFast(HikariPool.java:562) [HikariCP-3.4.1.jar!/:na]
	at com.zaxxer.hikari.pool.HikariPool.&lt;init&gt;(HikariPool.java:115) [HikariCP-3.4.1.jar!/:na]
	at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:112) [HikariCP-3.4.1.jar!/:na]
	at org.hibernate.engine.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:122) [hibernate-core-5.4.8.Final.jar!/:5.4.8.Final]

</code></pre><p>经过各种查找后，有大佬说docker默认的网络模式是bridge，容器内127.0.0.1访问不到的，把网络模式改为跟宿主机相同就ok，并提供了启动halo的脚本
<a href="https://bbs.halo.run/d/112-docker-halo-mysql">解决方案</a></p>
<pre><code>docker run --rm -it -d --net host --name halo-dev -p 8090:8090 -v ~/.halo:/root/.halo ruibaby/halo
</code></pre><p>经测试，可以启动了。</p>
<hr>
<p>感谢来访，本文到此结束</p>
]]></content></item></channel></rss>